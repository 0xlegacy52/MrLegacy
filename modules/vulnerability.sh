#!/bin/bash

# MR Legacy - Vulnerability Module
# Author: Abdulrahman Muhammad (0xLegacy)
# Version: 1.1.0

# Create necessary variables to track module execution
CALLED_FN_DIR="${target_dir}/.called_fn"
mkdir -p "$CALLED_FN_DIR" 2>/dev/null
chmod 755 "$CALLED_FN_DIR" 2>/dev/null

# Function to run Nuclei scanner
function nuclei_scan() {
    if is_completed "nuclei_scan"; then
        log_message "Nuclei scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "nuclei_scan" "Nuclei Vulnerability Scanning for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/vulnerabilities" 2>/dev/null
    local http_hosts="${target_dir}/recon/http/http_hosts.txt"
    local output_file="${target_dir}/vulnerabilities/nuclei_vulnerabilities.txt"
    local json_output="${target_dir}/vulnerabilities/nuclei_results.json"
    
    # Check if HTTP hosts file exists
    if [[ ! -f "$http_hosts" ]]; then
        log_message "No HTTP hosts file found. Using main target." "WARNING"
        mkdir -p "${target_dir}/recon/http" 2>/dev/null
        if is_valid_url "$target"; then
            echo "$target" > "$http_hosts"
        else
            echo "http://$target" > "$http_hosts"
        fi
    fi
    
    log_message "Starting Nuclei vulnerability scan" "INFO"
    
    # Check if nuclei is installed
    if command_exists "nuclei"; then
        log_message "Using Nuclei for vulnerability scanning" "INFO"
        
        # Determine scan depth based on DEEP flag
        local scan_options=""
        if [[ "$DEEP" == true ]]; then
            log_message "Deep scan enabled. Running comprehensive vulnerability scan." "INFO"
            scan_options="-severity info,low,medium,high,critical -c 50"
        else
            log_message "Standard scan enabled. Running focused vulnerability scan." "INFO"
            scan_options="-severity medium,high,critical -c 25"
        fi
        
        # Run nuclei
        execute_command "cat \"$http_hosts\" | nuclei $scan_options -o \"$output_file\" -json -jsonl \"$json_output\" -stats" "Vulnerability scanning with Nuclei" 1800 1
        
        # Check results
        if [[ -f "$output_file" && -s "$output_file" ]]; then
            # Count vulnerabilities by severity
            local critical=$(grep -c "\[critical\]" "$output_file" || echo "0")
            local high=$(grep -c "\[high\]" "$output_file" || echo "0")
            local medium=$(grep -c "\[medium\]" "$output_file" || echo "0")
            local low=$(grep -c "\[low\]" "$output_file" || echo "0")
            local info=$(grep -c "\[info\]" "$output_file" || echo "0")
            local total=$((critical + high + medium + low + info))
            
            log_message "Nuclei scan completed. Found $total vulnerabilities." "SUCCESS"
            log_message "Critical: $critical, High: $high, Medium: $medium, Low: $low, Info: $info" "INFO"
            
            end_function "nuclei_scan" 0 "Nuclei scan completed successfully"
            return 0
        else
            log_message "No vulnerabilities found using Nuclei" "WARNING"
            echo "No vulnerabilities found using Nuclei" > "$output_file"
            end_function "nuclei_scan" 0 "Nuclei scan completed - no vulnerabilities found"
            return 0
        fi
    else
        log_message "Nuclei not found. Vulnerability scanning skipped." "ERROR"
        echo "Vulnerability scanning skipped - Nuclei not found" > "$output_file"
        end_function "nuclei_scan" 1 "Vulnerability scanning skipped - Nuclei not found"
        return 1
    fi
}

# Function to scan for XSS vulnerabilities
function xss_scan() {
    if is_completed "xss_scan"; then
        log_message "XSS scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "xss_scan" "Cross-Site Scripting (XSS) Scan for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/vulnerabilities" 2>/dev/null
    local param_file="${target_dir}/enumeration/parameters/all_parameters.txt"
    local output_file="${target_dir}/vulnerabilities/xss_vulnerabilities.txt"
    
    # Check if parameters file exists
    if [[ ! -f "$param_file" || ! -s "$param_file" ]]; then
        log_message "No parameters file found or it's empty. Running parameter discovery first." "WARNING"
        parameter_discovery
    fi
    
    # Check again after potential discovery
    if [[ ! -f "$param_file" || ! -s "$param_file" ]]; then
        log_message "Still no parameters found. XSS scanning will be skipped." "WARNING"
        echo "XSS scanning skipped - no parameters to test" > "$output_file"
        end_function "xss_scan" 1 "XSS scanning skipped - no parameters to test"
        return 1
    fi
    
    log_message "Starting XSS vulnerability scan" "INFO"
    
    # Check for XSS scanning tools
    if command_exists "dalfox"; then
        log_message "Using Dalfox for XSS scanning" "INFO"
        
        # Create a file with URLs to test
        local urls_file="${target_dir}/.tmp/xss_urls.txt"
        mkdir -p "${target_dir}/.tmp" 2>/dev/null
        
        # Prepare URLs with parameters for testing
        while read -r param_line; do
            [[ -z "$param_line" ]] && continue
            
            # Ensure we have a full URL with parameter
            if [[ "$param_line" == http* && "$param_line" == *\?* ]]; then
                # Already a full URL with parameter
                echo "$param_line" >> "$urls_file"
            elif [[ "$param_line" == *=* ]]; then
                # Just a parameter, need to combine with a URL
                local http_hosts="${target_dir}/recon/http/http_hosts.txt"
                if [[ -f "$http_hosts" ]]; then
                    head -n 1 "$http_hosts" | while read -r host; do
                        [[ -z "$host" ]] && continue
                        echo "${host}?${param_line}" >> "$urls_file"
                    done
                else
                    # No HTTP hosts file, use main target
                    if is_valid_url "$target"; then
                        echo "${target}?${param_line}" >> "$urls_file"
                    else
                        echo "http://${target}?${param_line}" >> "$urls_file"
                    fi
                fi
            fi
        done < "$param_file"
        
        # Check if we have URLs to test
        if [[ -f "$urls_file" && -s "$urls_file" ]]; then
            # Run Dalfox
            execute_command "cat \"$urls_file\" | dalfox pipe --silence --skip-bav --no-color --format json --output \"${target_dir}/.tmp/dalfox_results.json\"" "XSS scanning with Dalfox" 1800 1
            
            # Process results
            if [[ -f "${target_dir}/.tmp/dalfox_results.json" && -s "${target_dir}/.tmp/dalfox_results.json" ]]; then
                # Extract vulnerable URLs
                cat "${target_dir}/.tmp/dalfox_results.json" | grep -o '"url":"[^"]*' | cut -d'"' -f4 > "$output_file"
                
                # Add payload information if available
                cat "${target_dir}/.tmp/dalfox_results.json" | grep -o '"payload":"[^"]*' | cut -d'"' -f4 | sed -e 's/^/Payload: /' >> "$output_file"
                
                # Count vulnerabilities
                local vuln_count=$(grep -c -v "^Payload" "$output_file")
                
                log_message "XSS scan completed. Found $vuln_count potential XSS vulnerabilities." "SUCCESS"
                end_function "xss_scan" 0 "XSS scan completed successfully"
                return 0
            else
                log_message "No XSS vulnerabilities found" "WARNING"
                echo "No XSS vulnerabilities found" > "$output_file"
                end_function "xss_scan" 0 "XSS scan completed - no vulnerabilities found"
                return 0
            fi
        else
            log_message "No suitable URLs for XSS testing" "WARNING"
            echo "XSS scanning skipped - no suitable URLs for testing" > "$output_file"
            end_function "xss_scan" 1 "XSS scanning skipped - no suitable URLs for testing"
            return 1
        fi
    else
        log_message "No XSS scanning tools found. XSS scanning skipped." "ERROR"
        echo "XSS scanning skipped - no tools available" > "$output_file"
        end_function "xss_scan" 1 "XSS scanning skipped - no tools available"
        return 1
    fi
}

# Function to scan for SQL injection vulnerabilities
function sqli_scan() {
    if is_completed "sqli_scan"; then
        log_message "SQL injection scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "sqli_scan" "SQL Injection Scan for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/vulnerabilities" 2>/dev/null
    local param_file="${target_dir}/enumeration/parameters/all_parameters.txt"
    local output_file="${target_dir}/vulnerabilities/sqli_vulnerabilities.txt"
    
    # Check if parameters file exists
    if [[ ! -f "$param_file" || ! -s "$param_file" ]]; then
        log_message "No parameters file found or it's empty. Running parameter discovery first." "WARNING"
        parameter_discovery
    fi
    
    # Check again after potential discovery
    if [[ ! -f "$param_file" || ! -s "$param_file" ]]; then
        log_message "Still no parameters found. SQL injection scanning will be skipped." "WARNING"
        echo "SQL injection scanning skipped - no parameters to test" > "$output_file"
        end_function "sqli_scan" 1 "SQL injection scanning skipped - no parameters to test"
        return 1
    fi
    
    log_message "Starting SQL injection vulnerability scan" "INFO"
    
    # Check for SQLi scanning tools
    if command_exists "sqlmap"; then
        log_message "Using SQLMap for SQL injection scanning" "INFO"
        
        # Create a file with URLs to test
        local urls_file="${target_dir}/.tmp/sqli_urls.txt"
        mkdir -p "${target_dir}/.tmp" 2>/dev/null
        
        # Prepare URLs with parameters for testing (similar to XSS scan)
        while read -r param_line; do
            [[ -z "$param_line" ]] && continue
            
            # Ensure we have a full URL with parameter
            if [[ "$param_line" == http* && "$param_line" == *\?* ]]; then
                # Already a full URL with parameter
                echo "$param_line" >> "$urls_file"
            elif [[ "$param_line" == *=* ]]; then
                # Just a parameter, need to combine with a URL
                local http_hosts="${target_dir}/recon/http/http_hosts.txt"
                if [[ -f "$http_hosts" ]]; then
                    head -n 1 "$http_hosts" | while read -r host; do
                        [[ -z "$host" ]] && continue
                        echo "${host}?${param_line}" >> "$urls_file"
                    done
                else
                    # No HTTP hosts file, use main target
                    if is_valid_url "$target"; then
                        echo "${target}?${param_line}" >> "$urls_file"
                    else
                        echo "http://${target}?${param_line}" >> "$urls_file"
                    fi
                fi
            fi
        done < "$param_file"
        
        # Check if we have URLs to test
        if [[ -f "$urls_file" && -s "$urls_file" ]]; then
            # Create output directory for SQLMap
            mkdir -p "${target_dir}/vulnerabilities/sqlmap" 2>/dev/null
            
            # Run SQLMap with safe settings
            log_message "Running SQLMap with safe settings" "INFO"
            execute_command "sqlmap -m \"$urls_file\" --batch --smart --level=1 --risk=1 --output-dir=\"${target_dir}/vulnerabilities/sqlmap\" --disable-coloring" "SQL injection scanning with SQLMap" 3600 1
            
            # Extract results
            log_message "Processing SQLMap results" "INFO"
            > "$output_file"
            
            # Find vulnerable URLs
            for log_file in $(find "${target_dir}/vulnerabilities/sqlmap" -name "log" 2>/dev/null); do
                if grep -q "is vulnerable" "$log_file"; then
                    # Extract URL and injection point
                    local url=$(grep -o "URL: '[^']*" "$log_file" | cut -d "'" -f2)
                    local injection=$(grep -o "Parameter: '[^']*" "$log_file" | cut -d "'" -f2)
                    local injection_type=$(grep -o "Type: [a-zA-Z0-9 ]*" "$log_file" | head -n 1)
                    
                    echo "Vulnerable URL: $url" >> "$output_file"
                    echo "Injection Point: $injection" >> "$output_file"
                    echo "Injection Type: $injection_type" >> "$output_file"
                    echo "-------------------" >> "$output_file"
                fi
            done
            
            # Count vulnerabilities
            local vuln_count=$(grep -c "Vulnerable URL:" "$output_file")
            
            if [[ $vuln_count -gt 0 ]]; then
                log_message "SQL injection scan completed. Found $vuln_count potential SQL injection vulnerabilities." "SUCCESS"
                end_function "sqli_scan" 0 "SQL injection scan completed successfully"
                return 0
            else
                log_message "No SQL injection vulnerabilities found" "WARNING"
                echo "No SQL injection vulnerabilities found" > "$output_file"
                end_function "sqli_scan" 0 "SQL injection scan completed - no vulnerabilities found"
                return 0
            fi
        else
            log_message "No suitable URLs for SQL injection testing" "WARNING"
            echo "SQL injection scanning skipped - no suitable URLs for testing" > "$output_file"
            end_function "sqli_scan" 1 "SQL injection scanning skipped - no suitable URLs for testing"
            return 1
        fi
    else
        log_message "No SQL injection scanning tools found. SQL injection scanning skipped." "ERROR"
        echo "SQL injection scanning skipped - no tools available" > "$output_file"
        end_function "sqli_scan" 1 "SQL injection scanning skipped - no tools available"
        return 1
    fi
}

# Function to scan for open redirect vulnerabilities
function openredirect_scan() {
    if is_completed "openredirect_scan"; then
        log_message "Open redirect scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "openredirect_scan" "Open Redirect Vulnerability Scan for $target"
    
    # Create output directories
    mkdir -p "${target_dir}/vulnerabilities" 2>/dev/null
    local param_file="${target_dir}/enumeration/parameters/all_parameters.txt"
    local output_file="${target_dir}/vulnerabilities/openredirect_vulnerabilities.txt"
    
    # Check if parameters file exists
    if [[ ! -f "$param_file" || ! -s "$param_file" ]]; then
        log_message "No parameters file found or it's empty. Running parameter discovery first." "WARNING"
        parameter_discovery
    fi
    
    # Check again after potential discovery
    if [[ ! -f "$param_file" || ! -s "$param_file" ]]; then
        log_message "Still no parameters found. Open redirect scanning will be skipped." "WARNING"
        echo "Open redirect scanning skipped - no parameters to test" > "$output_file"
        end_function "openredirect_scan" 1 "Open redirect scanning skipped - no parameters to test"
        return 1
    fi
    
    log_message "Starting open redirect vulnerability scan" "INFO"
    
    # Basic open redirect test with curl
    if command_exists "curl"; then
        log_message "Using curl for basic open redirect tests" "INFO"
        
        # Create a list of potential redirect parameters
        local redirect_params=(
            "url" "redirect" "redirect_to" "redirecturl" "return" "return_url" "returnurl"
            "goto" "next" "target" "link" "dest" "destination" "redir" "redirect_uri"
            "r" "uri" "u" "to" "out" "view" "dir" "path" "continue" "origin" "callback"
        )
        
        # Create test URLs
        local urls_file="${target_dir}/.tmp/redirect_urls.txt"
        mkdir -p "${target_dir}/.tmp" 2>/dev/null
        > "$urls_file"
        
        # Prepare payload
        local payload="https://evil.com"
        local encoded_payload=$(url_encode "$payload")
        
        # Extract URLs with redirect parameters
        for param in "${redirect_params[@]}"; do
            grep -i "$param=" "$param_file" >> "${target_dir}/.tmp/redirect_params.txt" 2>/dev/null
        done
        
        # Create full URLs with payloads
        if [[ -f "${target_dir}/.tmp/redirect_params.txt" && -s "${target_dir}/.tmp/redirect_params.txt" ]]; then
            while read -r param_line; do
                [[ -z "$param_line" ]] && continue
                
                # Extract parameter name and create test URL
                local param_name=$(echo "$param_line" | grep -o '^[^=]*')
                
                # Find or create base URL
                local http_hosts="${target_dir}/recon/http/http_hosts.txt"
                if [[ -f "$http_hosts" && -s "$http_hosts" ]]; then
                    head -n 1 "$http_hosts" | while read -r host; do
                        [[ -z "$host" ]] && continue
                        
                        # Create a URL with the parameter and payload
                        echo "${host}?${param_name}=${encoded_payload}" >> "$urls_file"
                    done
                else
                    # No HTTP hosts file, use main target
                    if is_valid_url "$target"; then
                        echo "${target}?${param_name}=${encoded_payload}" >> "$urls_file"
                    else
                        echo "http://${target}?${param_name}=${encoded_payload}" >> "$urls_file"
                    fi
                fi
            done < "${target_dir}/.tmp/redirect_params.txt"
        fi
        
        # Test the URLs
        > "$output_file"
        
        if [[ -f "$urls_file" && -s "$urls_file" ]]; then
            log_message "Testing $(wc -l < "$urls_file") URLs for open redirect vulnerabilities" "INFO"
            
            while read -r test_url; do
                [[ -z "$test_url" ]] && continue
                
                log_message "Testing $test_url" "DEBUG"
                
                # Follow redirects and see where we end up
                local redirect_result=$(curl -s -L -I -m 10 "$test_url" | grep -i "location:" | tail -n 1)
                
                # Check if we're redirected to our payload
                if echo "$redirect_result" | grep -q -i "evil.com"; then
                    log_message "Found potential open redirect: $test_url" "SUCCESS"
                    echo "Vulnerable URL: $test_url" >> "$output_file"
                    echo "Redirects to: $redirect_result" >> "$output_file"
                    echo "-------------------" >> "$output_file"
                fi
            done < "$urls_file"
            
            # Count vulnerabilities
            local vuln_count=$(grep -c "Vulnerable URL:" "$output_file")
            
            if [[ $vuln_count -gt 0 ]]; then
                log_message "Open redirect scan completed. Found $vuln_count potential open redirect vulnerabilities." "SUCCESS"
                end_function "openredirect_scan" 0 "Open redirect scan completed successfully"
                return 0
            else
                log_message "No open redirect vulnerabilities found" "WARNING"
                echo "No open redirect vulnerabilities found" > "$output_file"
                end_function "openredirect_scan" 0 "Open redirect scan completed - no vulnerabilities found"
                return 0
            fi
        else
            log_message "No suitable parameters found for open redirect testing" "WARNING"
            echo "Open redirect scanning skipped - no suitable parameters for testing" > "$output_file"
            end_function "openredirect_scan" 1 "Open redirect scanning skipped - no suitable parameters"
            return 1
        fi
    else
        log_message "Curl not found. Open redirect scanning skipped." "ERROR"
        echo "Open redirect scanning skipped - no tools available" > "$output_file"
        end_function "openredirect_scan" 1 "Open redirect scanning skipped - no tools available"
        return 1
    fi
}

# Main vulnerability scanning function
function run_vulnerability_module() {
    log_message "Starting vulnerability scanning module for $target" "INFO"
    
    # Create output directories
    mkdir -p "${target_dir}/vulnerabilities" 2>/dev/null
    mkdir -p "${target_dir}/.tmp" 2>/dev/null
    
    # Create .called_fn directory with proper permissions
    CALLED_FN_DIR="${target_dir}/.called_fn"
    mkdir -p "$CALLED_FN_DIR" 2>/dev/null
    chmod 755 "$CALLED_FN_DIR" 2>/dev/null
    
    # Show banner
# Function to run CORS misconfiguration scanning
function cors_scan() {
    if is_completed "cors_scan"; then
        log_message "CORS scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "cors_scan" "CORS Misconfiguration Scanning for $target"
    
    mkdir -p "$target_dir/vulnerabilities/" 2>/dev/null
    output_file="$target_dir/vulnerabilities/cors_vulnerabilities.txt"
    
    if is_tool_installed "corsy"; then
        log_message "Running Corsy scanner on $target..." "INFO"
        corsy -u "https://$target" -o "$output_file.json" > /dev/null 2>&1
        
        # Parse results
        if [ -f "$output_file.json" ]; then
            jq . "$output_file.json" > "$output_file" 2>/dev/null
            log_message "CORS scan completed" "SUCCESS"
        else
            log_message "Corsy scan output not found" "ERROR"
        fi
    else
        log_message "Corsy not found. Using curl for basic CORS checks..." "WARNING"
        
        # Basic CORS check with curl
        echo "CORS Vulnerability Scan Results for $target" > "$output_file"
        echo "=====================================" >> "$output_file"
        echo "" >> "$output_file"
        
        # Test for CORS misconfiguration
        response=$(curl -sI -H "Origin: https://evil.com" "https://$target" | grep -i "Access-Control-Allow-Origin")
        
        if echo "$response" | grep -q "evil.com"; then
            echo "[VULNERABLE] CORS misconfiguration found: $response" >> "$output_file"
            log_message "CORS vulnerability found!" "WARNING"
            VULN_COUNT_CORS=1
        elif echo "$response" | grep -q "\*"; then
            echo "[POTENTIALLY VULNERABLE] CORS wildcard detected: $response" >> "$output_file"
            log_message "CORS potential vulnerability found (wildcard)" "WARNING"
            VULN_COUNT_CORS=1
        else
            echo "[INFO] No obvious CORS misconfiguration detected" >> "$output_file"
            log_message "No obvious CORS vulnerabilities found" "INFO"
            VULN_COUNT_CORS=0
        fi
    fi
    
    export VULN_COUNT_CORS=$VULN_COUNT_CORS
    save_vuln_count "cors" "$VULN_COUNT_CORS"
    end_function "cors_scan" $?
}

# Function to scan for information disclosure vulnerabilities
function info_disclosure_scan() {
    if is_completed "info_disclosure_scan"; then
        log_message "Information disclosure scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "info_disclosure_scan" "Information Disclosure Scanning for $target"
    
    mkdir -p "$target_dir/vulnerabilities/" 2>/dev/null
    output_file="$target_dir/vulnerabilities/info_disclosure_vulnerabilities.txt"
    
    echo "Information Disclosure Scan Results for $target" > "$output_file"
    echo "=====================================" >> "$output_file"
    echo "" >> "$output_file"
    
    # Common files that may expose sensitive information
    sensitive_files=(
        "/.git/HEAD"
        "/.env"
        "/.env.backup"
        "/.env.dev"
        "/.env.local"
        "/config.php"
        "/config.js"
        "/config.json"
        "/database.yml"
        "/credentials.txt"
        "/credentials.json"
        "/server-status"
        "/server-info"
        "/phpinfo.php"
        "/info.php"
        "/.bash_history"
        "/.mysql_history"
        "/web.config"
        "/wp-config.php"
        "/wp-config.bak"
        "/log.txt"
        "/logs/"
        "/backup/"
        "/backups/"
        "/.DS_Store"
        "/error_log"
        "/debug.log"
    )
    
    VULN_COUNT_INFO=0
    
    for file in "${sensitive_files[@]}"; do
        url="https://$target$file"
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "$url")
        
        if [ "$status_code" == "200" ]; then
            echo "[VULNERABLE] Found potentially exposed file: $url (Status: $status_code)" >> "$output_file"
            ((VULN_COUNT_INFO++))
        elif [ "$status_code" == "403" ]; then
            echo "[INFO] File exists but access is forbidden: $url (Status: $status_code)" >> "$output_file"
        fi
    done
    
    # Check for exposed API documentation
    api_docs=(
        "/api"
        "/api/docs"
        "/api/swagger"
        "/swagger"
        "/swagger-ui"
        "/swagger-ui.html"
        "/swagger/index.html"
        "/api-docs"
        "/graphql"
        "/graphiql"
    )
    
    for endpoint in "${api_docs[@]}"; do
        url="https://$target$endpoint"
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "$url")
        
        if [ "$status_code" == "200" ]; then
            echo "[POTENTIALLY VULNERABLE] Found exposed API documentation: $url (Status: $status_code)" >> "$output_file"
            ((VULN_COUNT_INFO++))
        fi
    done
    
    log_message "Found $VULN_COUNT_INFO potential information disclosure vulnerabilities" "INFO"
    
    export VULN_COUNT_INFO=$VULN_COUNT_INFO
    save_vuln_count "info" "$VULN_COUNT_INFO"
    end_function "info_disclosure_scan" $?
}

# Function to scan for SSRF vulnerabilities
function ssrf_scan() {
    if is_completed "ssrf_scan"; then
        log_message "SSRF scan already completed for $target" "INFO"
        return 0
    fi
    
    start_function "ssrf_scan" "SSRF Vulnerability Scanning for $target"
    
    mkdir -p "$target_dir/vulnerabilities/" 2>/dev/null
    output_file="$target_dir/vulnerabilities/ssrf_vulnerabilities.txt"
    
    if is_tool_installed "nuclei" && [ -d "$target_dir/recon/urls" ]; then
        log_message "Running SSRF checks with Nuclei..." "INFO"
        nuclei -l "$target_dir/recon/urls/all_urls.txt" -t ssrf -silent -o "$output_file" > /dev/null 2>&1
        
        if [ -f "$output_file" ]; then
            VULN_COUNT_SSRF=$(wc -l < "$output_file")
            log_message "SSRF scan completed. Found $VULN_COUNT_SSRF potential SSRF vulnerabilities." "SUCCESS"
        else
            VULN_COUNT_SSRF=0
            log_message "SSRF scan completed. No vulnerabilities found." "INFO"
            echo "No SSRF vulnerabilities detected" > "$output_file"
        fi
    else
        log_message "Nuclei not found or URL list not available. Using basic SSRF checks..." "WARNING"
        
        # Basic SSRF check
        echo "SSRF Vulnerability Scan Results for $target" > "$output_file"
        echo "=====================================" >> "$output_file"
        echo "" >> "$output_file"
        
        # Check for common SSRF parameters
        ssrf_params=("url" "uri" "link" "src" "dest" "destination" "redirect" "redirect_to" "redirect_uri" "return" "return_to" "file" "path" "reference" "site" "html" "val" "validate" "domain" "callback" "return_url" "return_path" "data" "page" "feed" "host" "port" "to" "out" "view" "dir")
        
        VULN_COUNT_SSRF=0
        
        # Find URLs from the target to test
        if [ -f "$target_dir/recon/urls/all_urls.txt" ]; then
            urls=$(cat "$target_dir/recon/urls/all_urls.txt")
        else
            urls="https://$target"
        fi
        
        # Use grep to find URL parameters
        echo "$urls" | grep -E "(\?|\&)([^=]+)=" | sort -u > "$target_dir/.tmp_urls_with_params.txt"
        
        if [ -s "$target_dir/.tmp_urls_with_params.txt" ]; then
            while read -r url; do
                for param in "${ssrf_params[@]}"; do
                    if echo "$url" | grep -qi "[?&]$param="; then
                        echo "[POTENTIALLY VULNERABLE] URL with potential SSRF parameter found: $url" >> "$output_file"
                        ((VULN_COUNT_SSRF++))
                        break
                    fi
                done
            done < "$target_dir/.tmp_urls_with_params.txt"
        else
            echo "[INFO] No URLs with parameters found to test for SSRF" >> "$output_file"
        fi
        
        log_message "SSRF scan completed. Found $VULN_COUNT_SSRF potential SSRF vulnerabilities." "INFO"
    fi
    
    export VULN_COUNT_SSRF=$VULN_COUNT_SSRF
    save_vuln_count "ssrf" "$VULN_COUNT_SSRF"
    end_function "ssrf_scan" $?
}

    show_vulnerability_banner
    
    # Run vulnerability scanning functions
    nuclei_scan
    xss_scan
    sqli_scan
    openredirect_scan
    cors_scan
    info_disclosure_scan
    ssrf_scan
    
    # Clean up temp files
    rm -rf "${target_dir}/.tmp" 2>/dev/null
    rm -f "${target_dir}/.tmp_urls_with_params.txt" 2>/dev/null
    
    # Calculate total vulnerabilities
    total_vulns=$((VULN_COUNT_NUCLEI + VULN_COUNT_XSS + VULN_COUNT_SQLI + VULN_COUNT_OPENREDIRECT + VULN_COUNT_CORS + VULN_COUNT_INFO + VULN_COUNT_SSRF))
    log_message "Total vulnerabilities found: $total_vulns" "INFO"
    
    log_message "Vulnerability scanning module completed for $target" "SUCCESS"
}

# Export functions
export -f nuclei_scan
export -f xss_scan
export -f sqli_scan
export -f openredirect_scan
export -f cors_scan
export -f info_disclosure_scan
export -f ssrf_scan
export -f run_vulnerability_module