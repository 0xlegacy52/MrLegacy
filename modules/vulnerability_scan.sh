#!/bin/bash
# MR Legacy - Vulnerability Scanning Module

# Function to run Nuclei scan
run_nuclei_scan() {
    log_message "Starting Nuclei scan on $target..." "INFO"
    
    # Setup Tor proxy if enabled
    setup_tor_proxy
    
    # Create output directory
    local output_dir="$target_dir/vulnerabilities"
    mkdir -p "$output_dir"
    
    # Check if Nuclei is installed
    if is_tool_installed "nuclei"; then
        # Get list of live hosts
        local live_hosts_file="$target_dir/subdomains/live_hosts.txt"
        
        if [ -f "$live_hosts_file" ] && [ -s "$live_hosts_file" ]; then
            log_message "Running Nuclei scan on live hosts..." "INFO"
            
            # Run Nuclei with default templates
            cat "$live_hosts_file" | grep -E "^https?://" | nuclei -silent -c "$threads" -o "$output_dir/nuclei_results.txt" > /dev/null 2>&1
            
            if [ $? -eq 0 ]; then
                log_message "Nuclei scan completed successfully" "SUCCESS"
                
                # Count vulnerabilities
                local count=$(wc -l < "$output_dir/nuclei_results.txt")
                if [ $count -gt 0 ]; then
                    log_message "Found $count potential vulnerabilities" "SUCCESS"
                else
                    log_message "No vulnerabilities found" "INFO"
                fi
                
                # Save results in different formats
                save_results "$output_dir/nuclei_results.txt" "$output_dir" "nuclei_vulnerabilities" "$output_format"
            else
                log_message "Nuclei scan failed or was interrupted" "ERROR"
            fi
        else
            log_message "No live hosts found. Run live host detection first." "WARNING"
        fi
    else
        log_message "Nuclei not found, skipping vulnerability scan" "WARNING"
    fi
    
    log_message "Nuclei vulnerability scan completed" "SUCCESS"
    return 0
}

# Function to run XSS scanner
run_xss_scan() {
    log_message "Starting XSS scan on $target..." "INFO"
    
    # Setup Tor proxy if enabled
    setup_tor_proxy
    
    # Create output directory
    local output_dir="$target_dir/vulnerabilities"
    mkdir -p "$output_dir"
    
    # Check if XSStrike is installed
    if is_tool_installed "xsstrike" || is_tool_installed "XSStrike.py"; then
        # Get parameters list if available
        local params_file="$target_dir/directories/parameters.txt"
        
        if [ -f "$params_file" ] && [ -s "$params_file" ]; then
            log_message "Running XSS scan with discovered parameters..." "INFO"
            
            # Create temporary output file
            local temp_output=$(mktemp)
            
            # Determine XSStrike command
            local xsstrike_cmd
            if is_tool_installed "xsstrike"; then
                xsstrike_cmd="xsstrike"
            else
                # Try to find XSStrike.py
                xsstrike_cmd=$(find /usr -name "XSStrike.py" 2>/dev/null | head -n 1)
                if [ -z "$xsstrike_cmd" ]; then
                    log_message "XSStrike.py not found, skipping XSS scan" "WARNING"
                    return 1
                fi
                xsstrike_cmd="python3 $xsstrike_cmd"
            fi
            
            # Run XSStrike on each parameter
            while IFS= read -r param || [[ -n "$param" ]]; do
                # Skip empty lines
                if [ -z "$param" ]; then
                    continue
                fi
                
                log_message "Testing parameter: $param" "INFO"
                
                # Run XSStrike
                $xsstrike_cmd --url "$target?$param=test" --crawl --level 3 >> "$temp_output" 2>/dev/null
                
            done < "$params_file"
            
            # Check if any vulnerabilities were found
            if grep -q "Vulnerable" "$temp_output"; then
                log_message "XSS vulnerabilities found" "SUCCESS"
                grep -A 5 "Vulnerable" "$temp_output" > "$output_dir/xss_vulnerabilities.txt"
            else
                log_message "No XSS vulnerabilities found" "INFO"
                echo "No XSS vulnerabilities found" > "$output_dir/xss_vulnerabilities.txt"
            fi
            
            # Save results in different formats
            save_results "$output_dir/xss_vulnerabilities.txt" "$output_dir" "xss_vulnerabilities" "$output_format"
            
            # Cleanup
            rm -f "$temp_output"
        else
            log_message "No parameters found. Run parameter discovery first." "WARNING"
        fi
    else
        log_message "XSStrike not found, skipping XSS scan" "WARNING"
    fi
    
    log_message "XSS scan completed" "SUCCESS"
    return 0
}

# Function to run SQL injection scanner
run_sqli_scan() {
    log_message "Starting SQL injection scan on $target..." "INFO"
    
    # Setup Tor proxy if enabled
    setup_tor_proxy
    
    # Create output directory
    local output_dir="$target_dir/vulnerabilities"
    mkdir -p "$output_dir"
    
    # Check if SQLmap is installed
    if is_tool_installed "sqlmap"; then
        # Get parameters list if available
        local params_file="$target_dir/directories/parameters.txt"
        
        if [ -f "$params_file" ] && [ -s "$params_file" ]; then
            log_message "Running SQLmap with discovered parameters..." "INFO"
            
            # Create temporary output file
            local temp_output=$(mktemp)
            
            # Run SQLmap on each parameter
            while IFS= read -r param || [[ -n "$param" ]]; do
                # Skip empty lines
                if [ -z "$param" ]; then
                    continue
                fi
                
                log_message "Testing parameter: $param" "INFO"
                
                # Run SQLmap
                sqlmap -u "$target?$param=1" --batch --level=1 --risk=1 --threads="$threads" --output-dir="$output_dir/sqlmap" > "$temp_output" 2>&1
                
                # Check if vulnerability was found
                if grep -q "is vulnerable" "$temp_output"; then
                    log_message "SQL injection vulnerability found in parameter: $param" "SUCCESS"
                    echo "Parameter: $param is vulnerable to SQL injection" >> "$output_dir/sqli_vulnerabilities.txt"
                    cat "$temp_output" >> "$output_dir/sqli_vulnerabilities_details.txt"
                fi
            done < "$params_file"
            
            # Check if any vulnerabilities were found
            if [ -f "$output_dir/sqli_vulnerabilities.txt" ]; then
                log_message "SQL injection vulnerabilities found" "SUCCESS"
            else
                log_message "No SQL injection vulnerabilities found" "INFO"
                echo "No SQL injection vulnerabilities found" > "$output_dir/sqli_vulnerabilities.txt"
            fi
            
            # Save results in different formats
            save_results "$output_dir/sqli_vulnerabilities.txt" "$output_dir" "sqli_vulnerabilities" "$output_format"
            
            # Cleanup
            rm -f "$temp_output"
        else
            log_message "No parameters found. Run parameter discovery first." "WARNING"
        fi
    else
        log_message "SQLmap not found, skipping SQL injection scan" "WARNING"
    fi
    
    log_message "SQL injection scan completed" "SUCCESS"
    return 0
}

# Function to run Open Redirect scanner
run_openredirect_scan() {
    log_message "Starting Open Redirect scan on $target..." "INFO"
    
    # Setup Tor proxy if enabled
    setup_tor_proxy
    
    # Create output directory
    local output_dir="$target_dir/vulnerabilities"
    mkdir -p "$output_dir"
    
    # Get parameters list if available
    local params_file="$target_dir/directories/parameters.txt"
    
    if [ -f "$params_file" ] && [ -s "$params_file" ]; then
        log_message "Testing for Open Redirect vulnerabilities..." "INFO"
        
        # Payloads for testing open redirect
        local payloads=(
            "//evil.com"
            "https://evil.com"
            "//google.com"
            "//127.0.0.1"
            "/%09/google.com"
            "/%5cgoogle.com"
            "//%0D%0Agoogle.com"
        )
        
        # Test each parameter with each payload
        while IFS= read -r param || [[ -n "$param" ]]; do
            # Skip empty lines
            if [ -z "$param" ]; then
                continue
            fi
            
            log_message "Testing parameter: $param" "INFO"
            
            for payload in "${payloads[@]}"; do
                # Create the test URL
                local test_url="$target?$param=$payload"
                
                # Check for redirect
                local redirect=$(curl -s -I -L --max-redirs 3 -w "%{url_effective}" -o /dev/null "$test_url")
                
                # Check if redirect contains our payload
                if echo "$redirect" | grep -q "evil.com\|google.com\|127.0.0.1"; then
                    log_message "Open Redirect vulnerability found in parameter: $param with payload: $payload" "SUCCESS"
                    echo "Parameter: $param is vulnerable to Open Redirect with payload: $payload" >> "$output_dir/openredirect_vulnerabilities.txt"
                    echo "Test URL: $test_url" >> "$output_dir/openredirect_vulnerabilities.txt"
                    echo "Redirected to: $redirect" >> "$output_dir/openredirect_vulnerabilities.txt"
                    echo "---" >> "$output_dir/openredirect_vulnerabilities.txt"
                    break  # Move to next parameter after finding vulnerability
                fi
            done
        done < "$params_file"
        
        # Check if any vulnerabilities were found
        if [ -f "$output_dir/openredirect_vulnerabilities.txt" ]; then
            log_message "Open Redirect vulnerabilities found" "SUCCESS"
        else
            log_message "No Open Redirect vulnerabilities found" "INFO"
            echo "No Open Redirect vulnerabilities found" > "$output_dir/openredirect_vulnerabilities.txt"
        fi
        
        # Save results in different formats
        save_results "$output_dir/openredirect_vulnerabilities.txt" "$output_dir" "openredirect_vulnerabilities" "$output_format"
    else
        log_message "No parameters found. Run parameter discovery first." "WARNING"
    fi
    
    log_message "Open Redirect scan completed" "SUCCESS"
    return 0
}

# Function to run SSRF scanner
run_ssrf_scan() {
    log_message "Starting SSRF scan on $target..." "INFO"
    
    # Setup Tor proxy if enabled
    setup_tor_proxy
    
    # Create output directory
    local output_dir="$target_dir/vulnerabilities"
    mkdir -p "$output_dir"
    
    # Get parameters list if available
    local params_file="$target_dir/directories/parameters.txt"
    
    if [ -f "$params_file" ] && [ -s "$params_file" ]; then
        log_message "Testing for SSRF vulnerabilities..." "INFO"
        
        # Generate a unique callback domain for identifying SSRF
        local callback_id=$(generate_random_string 8)
        local callback_domain="$callback_id.burpcollaborator.net"
        
        # Alternative: Use a self-hosted callback server
        # local callback_url="http://your-callback-server.com/$callback_id"
        
        log_message "Using callback domain: $callback_domain" "INFO"
        
        # Payloads for testing SSRF
        local payloads=(
            "http://$callback_domain"
            "https://$callback_domain"
            "http://$callback_domain:80"
            "http://127.0.0.1:80\@$callback_domain"
            "http://127.0.0.1#$callback_domain"
        )
        
        # Test each parameter with each payload
        while IFS= read -r param || [[ -n "$param" ]]; do
            # Skip empty lines
            if [ -z "$param" ]; then
                continue
            fi
            
            log_message "Testing parameter: $param" "INFO"
            
            for payload in "${payloads[@]}"; do
                # Create the test URL
                local test_url="$target?$param=$payload"
                
                # Send the request
                curl -s -o /dev/null "$test_url"
                
                # Note: In a real scenario, you would need to check if the callback was received
                # Since we can't do that in this script, we'll just log the test URLs
                echo "Tested: $test_url" >> "$output_dir/ssrf_tests.txt"
            done
            
            echo "---" >> "$output_dir/ssrf_tests.txt"
        done < "$params_file"
        
        # Create note about manual verification
        cat > "$output_dir/ssrf_vulnerabilities.txt" << EOF
SSRF testing completed. Manual verification required.

To verify SSRF vulnerabilities:
1. Set up a callback server (e.g., Burp Collaborator, RequestBin)
2. Replace $callback_domain with your actual callback domain
3. Re-run the tests and check if your server receives connections

All test URLs have been saved to: ssrf_tests.txt
EOF
        
        # Save results in different formats
        save_results "$output_dir/ssrf_vulnerabilities.txt" "$output_dir" "ssrf_vulnerabilities" "$output_format"
        save_results "$output_dir/ssrf_tests.txt" "$output_dir" "ssrf_tests" "$output_format"
    else
        log_message "No parameters found. Run parameter discovery first." "WARNING"
    fi
    
    log_message "SSRF scan completed" "SUCCESS"
    return 0
}
