#!/bin/bash
# MR Legacy - Utility Module
# Contains common functions used by other modules

# Define colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
RESET='\033[0m'

# Logging function
log_message() {
    local message="$1"
    local level="${2:-INFO}"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    
    # Print to console
    case "$level" in
        "INFO")
            echo -e "${BLUE}[*] ${message}${RESET}"
            ;;
        "SUCCESS")
            echo -e "${GREEN}[+] ${message}${RESET}"
            ;;
        "WARNING")
            echo -e "${YELLOW}[!] ${message}${RESET}"
            ;;
        "ERROR")
            echo -e "${RED}[!] ${message}${RESET}"
            ;;
        *)
            echo -e "${WHITE}[$level] ${message}${RESET}"
            ;;
    esac
    
    # Log to file if LOG_DIR is defined
    if [ -n "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
        echo "[$timestamp] [$level] $message" >> "$LOG_DIR/mr_legacy.log"
    fi
}

# Check if a tool is installed
is_tool_installed() {
    local tool_name="$1"
    if command -v "$tool_name" &> /dev/null; then
        return 0
    else
        return 1
    fi
}

# Convert list to JSON
convert_to_json() {
    local input_file="$1"
    local output_file="$2"
    local title="$3"
    
    # Create a JSON structure
    echo "{" > "$output_file"
    echo "  \"$title\": [" >> "$output_file"
    
    # Read the input file line by line
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines
        if [ -z "$line" ]; then
            continue
        fi
        
        # Add the line as a JSON element
        echo "    \"$line\"," >> "$output_file"
    done < "$input_file"
    
    # Remove the trailing comma from the last element
    sed -i '$ s/,$//' "$output_file"
    
    # Close the JSON structure
    echo "  ]" >> "$output_file"
    echo "}" >> "$output_file"
}

# Convert list to HTML
convert_to_html() {
    local input_file="$1"
    local output_file="$2"
    local title="$3"
    
    # Create HTML header
    cat > "$output_file" << EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MR Legacy - $title</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .info {
            padding: 10px;
            background-color: #f9f9f9;
            border-left: 4px solid #3498db;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.8em;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MR Legacy - $title</h1>
        <div class="info">
            <p>Target: $target</p>
            <p>Date: $(date +"%Y-%m-%d %H:%M:%S")</p>
        </div>
        <table>
            <thead>
                <tr>
                    <th>$title</th>
                </tr>
            </thead>
            <tbody>
EOF
    
    # Add each line as a table row
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines
        if [ -z "$line" ]; then
            continue
        fi
        
        # Add the line as a table row
        echo "                <tr><td>$line</td></tr>" >> "$output_file"
    done < "$input_file"
    
    # Add HTML footer
    cat >> "$output_file" << EOF
            </tbody>
        </table>
        <div class="footer">
            <p>Generated by MR Legacy - Bug Bounty Hunting Tool</p>
            <p>Author: Abdulrahman Muhammad (0xLegacy)</p>
        </div>
    </div>
</body>
</html>
EOF
}

# Save results in different formats
save_results() {
    local input_file="$1"
    local output_dir="$2"
    local title="$3"
    local formats="$4"
    
    # Create directory if it doesn't exist
    mkdir -p "$output_dir"
    
    # Determine which formats to save
    if [ "$formats" = "all" ] || [ "$formats" = "txt" ]; then
        cp "$input_file" "$output_dir/$title.txt"
        log_message "Results saved as TXT: $output_dir/$title.txt" "SUCCESS"
    fi
    
    if [ "$formats" = "all" ] || [ "$formats" = "json" ]; then
        convert_to_json "$input_file" "$output_dir/$title.json" "$title"
        log_message "Results saved as JSON: $output_dir/$title.json" "SUCCESS"
    fi
    
    if [ "$formats" = "all" ] || [ "$formats" = "html" ]; then
        convert_to_html "$input_file" "$output_dir/$title.html" "$title"
        log_message "Results saved as HTML: $output_dir/$title.html" "SUCCESS"
    fi
}

# Setup Tor proxy if enabled
setup_tor_proxy() {
    if $tor_enabled; then
        # Check if Tor is installed
        if ! is_tool_installed "tor"; then
            log_message "Tor is not installed. Please install Tor to use this feature." "ERROR"
            return 1
        fi
        
        # Check if Tor service is running
        if ! pgrep -x "tor" > /dev/null; then
            log_message "Starting Tor service..." "INFO"
            sudo service tor start
            sleep 2
        fi
        
        # Check if Tor is now running
        if pgrep -x "tor" > /dev/null; then
            log_message "Tor is running. Proxy is enabled." "SUCCESS"
            export http_proxy="socks5://127.0.0.1:9050"
            export https_proxy="socks5://127.0.0.1:9050"
            return 0
        else
            log_message "Failed to start Tor service." "ERROR"
            return 1
        fi
    else
        # Disable proxy settings if Tor is not enabled
        unset http_proxy
        unset https_proxy
        return 0
    fi
}

# Function to display a progress spinner
show_spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    while ps -p $pid > /dev/null; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Press any key to continue
press_any_key() {
    echo ""
    read -n 1 -s -r -p "Press any key to continue..."
    echo ""
}

# Extract domain from URL
extract_domain() {
    local url="$1"
    
    # Remove protocol (http://, https://)
    domain=$(echo "$url" | sed -E 's#^https?://##')
    
    # Remove path and query parameters
    domain=$(echo "$domain" | cut -d'/' -f1)
    
    # Remove port if present
    domain=$(echo "$domain" | cut -d':' -f1)
    
    echo "$domain"
}

# Generate a random string
generate_random_string() {
    local length="${1:-8}"
    cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w "$length" | head -n 1
}

# Check if a given URL is accessible
is_url_accessible() {
    local url="$1"
    local timeout="${2:-5}"
    
    # Try to connect to the URL with a timeout
    if curl --output /dev/null --silent --head --fail --max-time "$timeout" "$url"; then
        return 0  # URL is accessible
    else
        return 1  # URL is not accessible
    fi
}

# Validate IP address
is_valid_ip() {
    local ip="$1"
    local stat=1
    
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        IFS='.' read -r -a ip_segments <<< "$ip"
        [[ ${ip_segments[0]} -le 255 && ${ip_segments[1]} -le 255 && ${ip_segments[2]} -le 255 && ${ip_segments[3]} -le 255 ]]
        stat=$?
    fi
    
    return $stat
}

# Get the current timestamp
get_timestamp() {
    date +"%Y-%m-%d_%H-%M-%S"
}

# Split a file into chunks for parallel processing
split_file_for_parallel() {
    local input_file="$1"
    local num_chunks="$2"
    local output_prefix="$3"
    
    # Count number of lines in input file
    local line_count=$(wc -l < "$input_file")
    
    # Calculate lines per chunk (rounded up)
    local lines_per_chunk=$(( (line_count + num_chunks - 1) / num_chunks ))
    
    # Split the file
    split -l "$lines_per_chunk" "$input_file" "$output_prefix"
}
